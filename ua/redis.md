# Про цю книгу

## Ліцензія

Маленька книжка про Redis (ориг. «Little Redis Book») ліцензована Attribution-NonCommercial 3.0 Unported. Ви не повинні платити за цю книгу.

Ви можете вільно копіювати, розповсюджувати, змінювати або демонструвати цю книгу. Однак я прошу вас завжди вказувати мене, Карла Сеґуіна (Karl Seguin), як автора книги та не використовувати її в комерційних цілях.

Ви можете ознайомитися з *повним текстом* **ліцензії за адресою**:

<http://creativecommons.org/licenses/by-nc/3.0/legalcode>

## Про автора

Карл Сеґуін (Karl Seguin) — розробник з досвідом роботи в різних галузях та технологіях. Він є активним учасником проектів з відкритим кодом, технічним письменником та періодичним доповідачем. Він написав низку статей, а також кілька інструментів про Redis. Redis забезпечує ранжування та статистику його безкоштовного сервісу для розробників казуальних ігор: [mogade.com](http://mogade.com/).

Карл написав [The Little MongoDB Book](http://openmymind.net/2011/3/28/The-Little-MongoDB-Book/), безкоштовну і популярну книгу про MongoDB.

Його блог можна знайти за адресою <http://openmymind.net>, а твіти — за посиланням [`@karlseguin`](http://twitter.com/karlseguin).

## З вдячністю за підтримку

Особлива подяка [Перри Неалу](https://twitter.com/perryneal) за те, що поділився зі мною своїми очима, розумом і пристрастю. Ви надали мені неоціненну допомогу. Дякую.

## Актуальна версія

Актуальна версія цієї книги (мовою оригіналу) доступна за адресою:
<http://github.com/karlseguin/the-little-redis-book>

## Переклад

Цей переклад виконано виклочно з освітньою метою та загальною популяризацією нереляційних баз даних (nRDMBS / noSQL), зокрема Redis. Загалом ця невелика книга може бути непоганим навчальним посібником для початку ознайомлення з підходами до нереляційних систем керування базами даних на прикладі Redis.

Перeклад був виконаний студентом університету [SET University](https://www.setuniversity.edu.ua/en/)

**Дисклеймер**: люди, що виконували переклад і редакційні правки **НЕ Є** професійними перекладачами та редакторами. Переклад і редагування було здійснено на власний розсуд, із урахуванням української стилістики та граматики разом із збереженням оригінальної логіки викладання матеріалу та професійної думки автора, але це не виключає наявність одруківок, незначних помилок або стилістичних недоробок. Ми просимо із повагою віднестись до чужої праці. Якщо ви помітили будь-яку помилку, одруківку, або маєте ідею як стилістично поліпшити викладення даного матеріалу, ми будемо щиро раді побачити ваш PR до цього [репозиторію](https://github.com/zemliany/the-little-redis-book) із пропозиціями або виправленнями. Дякуємо! 

# Вступ

За останні кілька років технології та інструменти, що використовуються для збереження та пошуку даних, розвивалися неймовірними темпами. Хоча можна з упевненістю сказати, що реляційні бази даних не збираються нікуди зникати, можна також стверджувати, що екосистема навколо даних ніколи не буде такою, як раніше.

З усіх нових інструментів та рішень для мене найцікавішим є Redis. Чому? По-перше, тому що його неймовірно легко освоїти. Години — це правильна одиниця виміру, коли йдеться про час, необхідний для того, щоб засвоїти Redis. По-друге, він вирішує конкретний набір проблем, водночас залишаючись досить універсальним. Що це означає? Redis не намагається бути універсальним для всіх даних. Коли ви знайомитеся з Redis, ставатиме все очевиднішим, що в ньому можна, а що ні. І коли це відбувається, для розробника це чудовий досвід.

Хоча ви можете побудувати повну систему, використовуючи тільки Redis, я думаю, що більшість людей вважатимуть, що він доповнює їх більш загальне рішення для даних — будь то традиційна реляційна база даних, система, орієнтована на документи, або щось інше. Це рішення, яке ви використовуєте для реалізації конкретних функцій. У цьому сенсі воно схоже на механізм індексації. Ви не будете будувати всю свою програму на Lucene. Але коли вам потрібний хороший пошук, це набагато кращий досвід — як для вас, так і для ваших користувачів. Звичайно, на цьому схожість між Redis та індексувальними двигунами закінчується.

Мета цієї книги — закласти основи, необхідні для оволодіння Redis. Ми зосередимося на вивченні п'яти структур даних Redis і розглянемо різні підходи до моделювання даних. Ми також торкнемося деяких ключових адміністративних деталей і технік налагодження.

# Початок роботи

Всі ми вчимося по-різному: комусь подобається бруднити руки, хтось дивитися відео, а хтось воліє читати. Ніщо не допоможе вам зрозуміти Redis краще, ніж власний досвід. Redis легко встановити, і він має просту оболонку, яка надасть нам усе необхідне. Приділімо кілька хвилин, щоб запустити його на нашому комп'ютері.

## На Windows

Redis офіційно не підтримується на операційній системі Windows, але є доступні варіанти. Ви не будете використовувати їх у production, але я ніколи не стикався з жодними обмеженнями під час розробки.

Портовану версію яка підтримуєтья на ОС Windows від Microsoft Open Technologies, Inc. можна знайти за адресою <https://github.com/MSOpenTech/redis>. На момент написання цієї статті рішення не готове для використання у виробничих системах.

Інше рішення, яке доступне вже деякий час, можна знайти за адресою <https://github.com/dmajkic/redis/downloads>. Ви можете завантажити найновішу версію (яка повинна бути першою в списку). Розпакуйте zip-файл і, залежно від архітектури вашої системи, відкрийте папку `64bit` або `32bit`.

## На *nix and MacOSX

Для користувачів *nix та MacOSX найкращим варіантом є компіляція з вихідного коду. Інструкції, а також номер останньої версії, доступні за адресою <http://redis.io/download>. На момент написання цієї статті останньою версією є 3.0.3; для встановлення цієї версії потрібно виконати:

```
wget http://download.redis.io/releases/redis-3.0.3.tar.gz
tar xzf redis-3.0.3.tar.gz
cd redis-3.0.3
make
```

(Крім того, Redis доступний через різні менеджери пакетів. Наприклад, користувачі MacOSX з встановленим Homebrew можуть просто ввести `brew install redis`.)

Якщо ви отримали програму шляхом компіляції вихідного коду, бінарні файли знаходяться в каталозі `src`. Перейдіть до каталогу `src`, виконавши команду `cd src`.

## Запуск і підключення до Redis

Якщо все працює, бінарні файли Redis повинні бути доступні. Redis має кілька виконуваних файлів. Ми зосередимося на сервері Redis і командному інтерфейсі Redis (клієнт, схожий на DOS). Запустимо сервер. У Windows двічі клацніть на `redis-server`. У *nix/MacOSX запустіть `./redis-server`.

Якщо ви прочитаєте повідомлення про запуск, то побачите попередження про те, що файл `redis.conf` не вдалося знайти. Redis замість цього використовуватиме вбудовані значення за замовчуванням, що цілком підійде для наших потреб.

Далі запустіть консоль Redis, двічі клацнувши на `redis-cli` (Windows) або запустивши файл `./redis-cli` (*nix/MacOSX). Це підключить вас до локального сервера, що працює на стандартному порту (6379).

Ви можете перевірити, чи все працює, ввівши `info` в інтерфейс командного рядка. Сподіваємося, ви побачите низку пар ключ-значення, які надають багато інформації про стан сервера.

Якщо у вас виникли проблеми з налаштуванням, описаним вище, рекомендую звернутися за допомогою до [офіційної групи підтримки Redis](https://groups.google.com/forum/#!forum/redis-db).

# Драйвери Redis

Як ви скоро дізнаєтеся, API Redis найкраще описати як явний набір функцій. Він має дуже простий і процедурний вигляд. Це означає, що незалежно від того, чи використовуєте ви інструмент командного рядка, чи драйвер для вашої улюбленої мови програмування, все буде дуже схоже. Тому, якщо ви віддаєте перевагу роботі з мовою програмування, у вас не повинно виникнути жодних проблем. Якщо бажаєте, перейдіть на [сторінку клієнта](http://redis.io/clients) і завантажте відповідний драйвер.

# Розділ 1 - Основи

Чим особливий Redis? Які типи проблем він вирішує? На що слід звернути увагу розробникам під час його використання? Перш ніж відповісти на ці питання, потрібно зрозуміти, що таке Redis.

Redis часто описують як постійне сховище ключів-значень в оперативній пам'яті. Я не вважаю це точним описом. Redis дійсно зберігає всі дані в оперативній пам'яті (про це детальніше трохи пізніше) і записує їх на диск для збереження, але це набагато більше, ніж просте сховище ключів-значень. Важливо нівелювати це хибне уявлення, інакше ваше розуміння Redis і проблем, які він вирішує, буде занадто вузьким.

Насправді Redis надає п'ять різних структур даних, лише одна з яких є типовою структурою ключ-значення. Розуміння цих п'яти структур даних, їхнього функціонування, методів, які вони надають, та того, що ви можете моделювати за їх допомогою, є ключем до розуміння Redis. Але спочатку давайте розберемося, що означає надавати структури даних.

Якщо застосувати це поняття структури даних до реляційного світу, можна сказати, що бази даних надають доступ до єдиної структури даних — таблиць. Таблиці є одночасно складними і гнучкими. За допомогою таблиць можна моделювати, зберігати і обробляти майже все. Однак їх універсальний характер має і свої недоліки. Зокрема, не все є настільки простим і швидким, як хотілося б. А що, якби замість універсальної структури ми використовували більш спеціалізовані структури? Можливо, деякі речі ми не зможемо зробити (або, принаймні, не зможемо зробити дуже добре), але натомість ми точно виграємо в простоті та швидкості?

Використовувати конкретні структури даних для конкретних проблем? Хіба не так ми пишемо код? Ви ж не використовуєте хеш-таблицю для кожного елемента даних, як і не використовуєте скалярну змінну. На мій погляд, це визначає підхід Redis. Якщо ви маєте справу зі скалярними величинами, списками, хешами або наборами, чому б не зберігати їх як скалярні величини, списки, хеші та набори? Чому перевірка наявності значення має бути складнішою, ніж виклик `exists(key)`, або повільнішою, ніж O(1) (постійний час пошуку, який не сповільнюється незалежно від кількості елементів)?

## Будівельні блоки

### Бази даних (Databases)

Redis має ту саму базову концепцію бази даних, з якою ви вже знайомі. База даних містить набір даних. Типовим випадком використання бази даних є групування всіх даних програми та їх відокремлення від даних іншої програми.

У Redis бази даних просто ідентифікуються за номером, причому база даних за замовчуванням має номер `0`. Якщо ви хочете перейти до іншої бази даних, ви можете зробити це за допомогою команди `select`. У командному рядку введіть `select 1`. Redis повинен відповісти повідомленням `OK`, а ваш підказка повинна змінитися на щось на зразок `redis 127.0.0.1:6379[1]>`. Якщо ви хочете повернутися до бази даних за замовчуванням, просто введіть `select 0` в командному рядку.

### Команди, ключі та значення (Commands, Keys and Values)

Хоча Redis — це більше, ніж просто сховище ключів-значень, в основі кожної з п'яти структур даних Redis лежить принаймні один ключ і одне значення. Перед тим, як перейти до інших доступних елементів інформації, необхідно обов'язково зрозуміти, що таке ключі та значення.

Ключі використовуються для ідентифікації фрагментів даних. Ми будемо часто мати справу з ключами, але поки що достатньо знати, що ключ може виглядати так: `users:leto`. Можна розумно припустити, що такий ключ містить інформацію про користувача з іменем `leto`. Двокрапка не має особливого значення для Redis, але використання роздільника є поширеним підходом, який люди використовують для організації своїх ключів.

Значення представляють фактичні дані, пов'язані з ключем. Вони можуть бути будь-якими. Іноді ви будете зберігати рядки, іноді цілі числа, іноді серіалізовані об'єкти (у форматі JSON, XML або іншому). Здебільшого Redis обробляє значення як масив байтів і не звертає уваги на їхній тип. Зверніть увагу, що різні драйвери по-різному обробляють серіалізацію (деякі залишають це на ваш розсуд), тому в цій книзі ми будемо говорити тільки про рядки, цілі числа та JSON.

Давайте трохи забруднимо руки. Введіть наступну команду:

```
set users:leto '{"name": "leto", "planet": "dune", "likes": ["spice"]}'
```

Це основна структура команди Redis. Спочатку ми маємо саму команду, в даному випадку `set`. Далі йдуть її параметри. Команда `set` приймає два параметри: ключ, який ми встановлюємо, та значення для нього. Багато команд, але не всі, приймають ключ (і коли приймають, то часто це перший параметр). Чи можете ви вгадати, як отримати це значення? Сподіваємося, ви відповіли (але не хвилюйтеся, якщо не були впевнені!):

```
get users:leto
```

Спробуйте погратися з іншими комбінаціями. Ключі та значення є основними поняттями, а команди `get` та `set` — найпростіший спосіб погратися з ними. Створіть більше користувачів, спробуйте різні типи ключів, спробуйте різні значення.

### Запити (Querying)

У міру того як ви поступово ознайомлюватиметеся з Redis, вам все більше стануть зрозумілими дві речі, що стосуватимуться Redis: ключі — це все, а значення — ніщо. Іншими словами, Redis не дозволяє запитувати значення об'єкта. З огляду на вищесказане, ми не можемо знайти користувачів, які живуть на планеті `dune`.

В багатьох це може викликати певне занепокоєння. Ми живемо у світі, де запити до даних є настільки гнучкими та потужними, що підхід Redis може здатися примітивним і непрактичним. Нехай це вас надто не турбує. Пам'ятайте, Redis — це не універсальне рішення. Будуть речі, які просто не підходять для нього (через обмеження запитів). Також врахуйте, що в деяких випадках ви знайдете нові способи моделювання даних.

Ми розглянемо більш конкретні приклади далі, але важливо зрозуміти цю основну особливість Redis. Це допоможе нам зрозуміти, чому значення можуть бути будь-якими — Redis ніколи не потрібно їх читати чи розуміти. Також це допоможе нам почати думати про моделювання в цьому новому світі.

### Памʼять та Персистентність (Memory and Persistence)

Ми вже згадували, що Redis є постійним сховищем, зберігаючи все в оперативній пам'яті. За замовчуванням, задля підтримки персистенності, Redis створює знімки бази даних на диск на основі кількості змінених ключів. Ви можете налаштувати систему так, щоб при зміні X ключів база даних зберігалася кожні Y секунд. За замовчуванням Redis зберігає базу даних кожні 60 секунд, якщо змінилося 1000 або більше ключів, і кожні 15 хвилин, якщо змінилося 9 або менше ключів.

Як альтернатива (як додаток до створення знімків), Redis може працювати в інкрементальному режимі (режимі дозапису). Кожного разу, коли ключ змінюється, на диску оновлюється файл, що доступний тільки в режимі дозапису. У деяких випадках прийнятно втратити дані за 60 секунд в обмін на продуктивність, якщо трапиться збій апаратного або програмного забезпечення. У деяких випадках така втрата є неприйнятною. Redis надає вам можливість вибору. У розділі 6 ми розглянемо третій варіант, який полягає у вивантаженні персистентності на ведений сервер.

Що стосується пам'яті, Redis зберігає всі ваші дані в оперативній пам'яті. Очевидним наслідком цього є вартість експлуатації Redis: оперативна пам'ять залишається найдорожчою операційною частиною серверного обладнання.

Я дійсно вважаю, що деякі розробники втратили уявлення про те, як мало місця можуть займати дані. Повне зібрання творів Вільяма Шекспіра займає приблизно 5,5 МБ пам'яті. Що стосується масштабування, інші рішення, як правило, обмежені пропускною здатністю вводу-виводу або процесора. Яке обмеження (оперативна пам'ять або пропускна здатність вводу-виводу) вимагатиме масштабування на більшу кількість машин, насправді залежить від типу даних і того, як ви їх зберігаєте та запитуєте. Якщо ви не зберігаєте великі мультимедійні файли в Redis, обсяг оперативної пам'яті, ймовірно, не буде проблемою. Для додатків, де це є проблемою, вам, ймовірно, доведеться поступитися пропускною здатністю вводу-виводу на користь обсягу оперативної пам'яті.

Redis дійсно додав підтримку віртуальної пам'яті. Однак ця функція була визнана невдалою (самими розробниками Redis) і її використання було припинено.

(До речі, файл з повним зібранням творів Шекспіра розміром 5,5 МБ можна стиснути приблизно до 2 МБ. Redis не виконує автоматичне стиснення, але, оскільки він обробляє значення як байти, немає причин, чому б не обміняти час обробки на оперативну пам'ять, стискаючи/розпаковуючи дані самостійно.)

### Збираємо все до купи

Ми торкнулися низки важливих тем. Перед тим, як заглибитися в Redis, я хотів би об'єднати деякі з них. Зокрема, обмеження запитів, структури даних та спосіб зберігання даних у пам'яті Redis.

Якщо обʼєднати ці три речі разом, ви отримаєте щось дивовижне: швидкість. Деякі люди думають: «Звичайно, Redis швидкий, адже все знаходиться в пам'яті». Але це лише частина правди. Справжня причина, чому Redis вигідно відрізняється від інших рішень, — це його спеціалізовані структури даних.

Як швидко? Це залежить від багатьох факторів — від того, які команди ви використовуєте, від типу даних тощо. Але продуктивність Redis зазвичай вимірюється в десятках тисяч або сотнях тисяч операцій **за секунду**. Ви можете запустити `redis-benchmark` (який знаходиться в тій самій папці, що й `redis-server` та `redis-cli`), щоб перевірити це самостійно.

Колись, я змінив код який використовував традиційну модель, на Redis. Тест із навантаженням, який я створив, зайняв більше 5 хвилин, щоб завершити використання реляційної моделі. У Redis це зайняло близько 150 мілісекунд. Ви не завжди отримаєте такий величезний виграш, але, сподіваємося, це дасть вам уявлення про те, про що ми говоримо.

Важливо розуміти цей аспект Redis, оскільки він впливає на взаємодію з ним. Розробники з досвідом роботи з SQL часто прагнуть мінімізувати кількість звернень до бази даних. Це хороша порада для будь-якої системи, включаючи Redis. Однак, враховуючи, що ми маємо справу з простішими структурами даних, іноді нам доведеться звертатися до сервера Redis кілька разів, щоб досягти своєї мети. Такі підходи доступу до даних спочатку можуть здаватися неприродними, але насправді це незначні витрати порівняно з продуктивністю, яку ми отримуємо.

## У цьому розділі

Хоча ми ледь встигли попрацювати з Redis, ми охопили широке коло тем. Не хвилюйтеся, якщо щось не зовсім зрозуміло, наприклад, запити. У наступному розділі ми перейдемо до більш практичних завдань, і, сподіваємося, всі ваші запитання знайдуть відповіді.

Основні висновки з цього розділу:

* Ключі — це рядки, які ідентифікують фрагменти даних (значення).

* Значення — це довільні масиви байтів, які Redis не враховує.

* Redis підтримує реалізацію п'яти спеціалізованих структур даних

* У сукупності вищезазначені особливості роблять Redis швидким і простим у використанні, але не підходять для всіх сценаріїв.

# Розділ 2 - Структури даних

Прийшов час розглянути п'ять структур даних Redis. Ми дамо розʼяснення, по кожній структурі даних, які методи доступні для них та для яких типів функцій їх можна використовувати.

Єдині конструкції Redis, які ми бачили досі, — це команди, ключі та значення. Досі нічого конкретного про структури даних не було сказано. Коли ми використовували команду `set`, як Redis знав, яку структуру даних використовувати? Виявляється, кожна команда є специфічною для певної структури даних. Наприклад, коли ви використовуєте `set`, ви зберігаєте значення в структурі даних типу `string`. Коли ви використовуєте `hset`, ви зберігаєте його в хеші. З огляду на невеликий розмір словника Redis, керувати такими типами досить доволі легко.

**[Веб-сайт Redis](http://redis.io/commands) містить чудову довідкову документацію. Немає сенсу повторювати роботу, яку вже зробили інші. Ми розглянемо лише найважливіші команди, необхідні для розуміння призначення структури даних.**

Немає нічого важливішого, ніж отримувати задоволення від побудови чогось нового. Ви завжди можете видалити всі значення з бази даних, ввівши `flushdb`, тому не соромтеся і пробуйте робити божевільні речі!

## Рядки (Strings)

Строкові типи даних (або рядки) — це найпростіші структури даних, доступні в Redis. Коли ви думаєте про пару ключ-значення, ви маєте на увазі строковий тип даних. Не плутайте їх з іншими типами, адже, як завжди, значення може бути будь-яким. Я вважаю за краще називати їх «скалярами», але, можливо, це лише моя особиста думка.

Ми вже бачили типовий випадок використання рядків — зберігання екземплярів об'єктів за ключем. Це те, що ви будете часто використовувати:

```
set users:leto '{"name": leto, "planet": dune, "likes": ["spice"]}'
```

Крім того, Redis дозволяє виконувати деякі типові операції. Наприклад, `strlen <key>` можна використовувати для отримання довжини значення ключа; `getrange <key> <start> <end>` повертає вказаний діапазон значення; `append <key> <value>` додає значення до існуючого значення (або створює його, якщо воно ще не існує). Спробуйте ці команди. Ось що я отримав:

```
> strlen users:leto
(integer) 50

> getrange users:leto 31 48
"\"likes\": [\"spice\"]"

> append users:leto " OVER 9000!!"
(integer) 62
```

Тепер ви, можливо, думаєте: «Це чудово, але це не має сенсу. Неможливо витягнути діапазон із JSON або додати значення». Ви маєте рацію. Головна ідея тут полягає в тому, що деякі команди, особливо з структурою даних рядка, мають сенс лише для певного типу даних.

Раніше ми дізналися, що Redis не звертає уваги на ваші значення. У більшості випадків це правда. Однак деякі рядкові команди є специфічними для певних типів або структур значень. У якості першочергового, невиразного прикладу, я бачу, що команди `append` і `getrange` можуть бути корисними в деяких спеціальних серіалізаціях, що вимагають економії місця. Як більш конкретний приклад, я наведу команди `incr`, `incrby`, `decr` і `decrby`. Вони збільшують або зменшують значення рядка:

```
> incr stats:page:about
(integer) 1
> incr stats:page:about
(integer) 2

> incrby ratings:video:12333 5
(integer) 5
> incrby ratings:video:12333 3
(integer) 8
```

Як ви можете собі уявити, рядки Redis чудово підходять для аналітики. Спробуйте збільшити значення `users:leto` (неціле значення) і подивіться, що станеться (ви повинні отримати помилку).

Більш просунутим прикладом є використання команд `setbit` та `getbit`. Існує [чудова публікація](http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/) про те, як Spool використовує ці дві команди для ефективної відповіді на питання «скільки унікальних відвідувачів ми мали сьогодні». Для 128 мільйонів користувачів ноутбук генерує відповідь менш ніж за 50 мс і використовує лише 16 МБ пам'яті.

Не важливо, чи розумієте ви, як працюють бітові мапи або як їх використовує Spool, важливіше зрозуміти, що рядки Redis є більш потужними, ніж здається на перший погляд. Проте найпоширенішими випадками є ті, що ми навели вище: зберігання об'єктів (складних чи простих) та лічильників. Крім того, оскільки отримання значення за ключем відбувається дуже швидко, рядки часто використовуються для кешування даних.

## Хеші (Hashes)

Хеші є хорошим прикладом того, чому називати Redis тільки сховищем ключів-значень не зовсім коректно. Бачите, багато в чому хеші схожі на рядки. Важлива відмінність полягає в тому, що вони надають додатковий рівень непрямої адресації: поле. Тому хеш-еквівалентами `set` і `get` є:

```
hset users:goku powerlevel 9000
hget users:goku powerlevel
```

Ми також можемо встановити кілька полів одночасно, отримати кілька полів одночасно, отримати всі поля та значення, перелічити всі поля або видалити певне поле:

```
hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age
```

Як бачите, хеші дають нам трохи більше контролю над простими строковими даними. Замість того, щоб зберігати користувача як одне серіалізоване значення, ми можемо використовувати хеш, щоб отримати більш точне представлення. Перевагою буде можливість витягувати та оновлювати/видаляти конкретні фрагменти даних, не отримуючи та не записуючи все значення.

Розгляд хешів з точки зору чітко визначеного об'єкта, такого як користувач, є ключовим для розуміння їхньої роботи. І це правда, що з міркувань продуктивності може бути корисним більш детальний контроль. Однак у наступному розділі ми розглянемо, як хеші можна використовувати для організації даних і спрощення запитів. На мій погляд, саме в цьому полягає справжня перевага хешів.

## Списки (Lists)

Списки дозволяють зберігати та обробляти масив значень для заданого ключа. Ви можете додавати значення до списку, отримувати перше або останнє значення та обробляти значення за заданим індексом. Списки зберігають свій порядок і мають ефективні операції на основі індексів. Ми можемо мати список `newusers`, який відстежує найновіших зареєстрованих користувачів на нашому сайті:

```
lpush newusers goku
ltrim newusers 0 49
```

Спочатку ми додаємо нового користувача в початок списку, а потім обрізаємо його так, щоб він містив тільки останні 50 користувачів. Це типовий шаблон. `ltrim` — це операція O(N), де N — кількість значень, які ми видаляємо. У цьому випадку, коли ми завжди обрізаємо після одного вставлення, фактично буде постійна продуктивність O(1) (оскільки N завжди дорівнюватиме 1).

Це також перший випадок, коли ми бачимо значення в одному ключі, що посилається на значення в іншому. Якщо ми хочемо отримати детальну інформацію про останніх 10 користувачів, ми зробимо наступну комбінацію:

```
ids = redis.lrange('newusers', 0, 9)
redis.mget(*ids.map {|u| "users:#{u}"})
```

Вище наведено фрагмент коду на мові Ruby, який ілюструє тип багаторазових циклів, про які ми говорили раніше.

Звичайно, списки корисні не тільки для зберігання посилань на інші ключі. Значення можуть бути будь-якими. Ви можете використовувати списки для зберігання журналів або відстеження шляху, який проходить користувач по сайту. Якщо ви створюєте гру, ви можете використовувати список для відстеження дій користувачів, що знаходяться в черзі.

## Множини (Sets)

Множини використовуються для зберігання унікальних значень і надання ряду операцій на основі наборів, таких як об'єднання. Множини не впорядковані, але вони забезпечують ефективні операції на основі значень. Список друзів є класичним прикладом використання множини:

```
sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia
```

Незалежно від того, скільки друзів має користувач, ми можемо ефективно визначити (O(1)), чи є користувач X другом користувача Y:

```
sismember friends:leto jessica
sismember friends:leto vladimir
```

Крім того, ми можемо побачити, чи мають дві або більше осіб спільних друзів:

```
sinter friends:leto friends:duncan
```

і навіть зберегти результат під новим ключем:

```
sinterstore friends:leto_duncan friends:leto friends:duncan
```

Множина чудово підходять для тегування або відстеження будь-яких інших властивостей значення, для яких дублікати не мають сенсу (або де ми хочемо застосувати операції над наборами, такі як перетин і об'єднання).

## Впорядковані Множини (Sorted Sets)

Останньою і найпотужнішою структурою даних є впорядкована множина. Якщо хеші схожі на рядки, але з полями, то впорядкована множина схожа на множину, але з оцінкою. Оцінка забезпечує можливості сортування та ранжування. Якщо ми хочемо отримати рейтинговий список друзів, ми можемо зробити так:

```
zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir
```

Хочете дізнатися, скільки друзів у `duncan` з рейтингом 90 або вище?

```
zcount friends:duncan 90 100
```

Як щодо того, щоб з'ясувати рейтинг «чані»?

```
zrevrank friends:duncan chani
```

Ми використовуємо `zrevrank` замість `zrank`, оскільки Redis за замовчуванням сортує від найнижчого до найвищого (а в цьому випадку ми сортуємо від найвищого до найнижчого). Найбільш очевидний випадок використання відсортованої множини — це система рейтингу. Насправді ж, відсортовані множини можуть бути корисними для будь-чого, що потрібно сортувати за деяким цілим числом і ефективно обробляти на основі цього балу.

## У цьому розділі

Це загальний огляд п'яти структур даних в Redis. Однією з цікавих особливостей Redis є те, що часто можна зробити більше, ніж здається на перший погляд. Ймовірно, існують способи використання строкових даних (рядків) і впорядкованих множин, про які ще ніхто не думав. Однак, якщо ви розумієте типові випадки використання, Redis виявиться ідеальним рішенням для будь-яких завдань. Крім того, не варто думати, що вам потрібно використовувати всі п'ять структур даних і різні методи, які пропонує Redis. Нерідко функції створюються з використанням лише декількох команд.

# Розділ 3 - Використання структур даних

У попередньому розділі ми розповіли про п'ять структур даних і навели декілька прикладів задач, які вони можуть вирішувати. Тепер час розглянути кілька більш складних, але поширених тем і шаблонів проектування.
## Асимптотична складність (Нотація «Big O»)

У цій книзі ми неодноразово згадували позначення `Big O` у вигляді `O(n)` або `O(1)`. Позначення Big O використовується для пояснення поведінки об'єкта за певної кількості елементів. У Redis воно використовується для визначення швидкості виконання команди залежно від кількості елементів, з якими ми працюємо.

Документація Redis містить інформацію про нотацію Big O для кожної команди. Також вказано фактори, що впливають на продуктивність. Розглянемо кілька прикладів.

Найшвидше, що може бути, це `O(1)`, що є константою. Незалежно від того, чи маємо справу з 5 елементами чи 5 мільйонами, ви отримаєте однакову продуктивність. Команда `sismember`, яка повідомляє, чи належить значення до набору, є `O(1)`. `sismember` є потужною командою, і її характеристики продуктивності є важливою причиною цього. Деякі команди Redis є `O(1)`.

Логарифмічний, або `O(log(N))`, є наступним за швидкістю варіантом, оскільки він потребує сканування все менших і менших розділів. Використовуючи цей тип підходу «розділяй і володарюй», дуже велика кількість елементів швидко розбивається на кілька ітерацій. `zadd` є командою `O(log(N))`, де `N` — кількість елементів, що вже знаходяться в відсортованому наборі.

Далі ми маємо лінійні команди, або O(N). Пошук неіндексованого стовпця в таблиці є операцією O(N). Так само як і використання команди `ltrim`. Однак у випадку `ltrim` N не є кількістю елементів у списку, а кількістю елементів, що видаляються. Використання `ltrim` для видалення 1 елемента зі списку, що містить мільйони елементів, буде швидшим, ніж використання `ltrim` для видалення 10 елементів зі списку, що містить тисячі елементів. (Хоча, ймовірно, обидва варіанти будуть настільки швидкими, що ви не зможете виміряти час.)

`zremrangebyscore`, який видаляє елементи з відсортованого набору з балом між мінімальним і максимальним значенням, має складність `O(log(N)+M)`. Це робить його змішаним. З документації ми бачимо, що `N` — це загальна кількість елементів у наборі, а `M` — кількість елементів, які потрібно видалити. Іншими словами, кількість елементів, які будуть видалені, ймовірно, буде більш значущою з точки зору продуктивності, ніж загальна кількість елементів у наборі.

Команда `sort`, яку ми детальніше розглянемо в наступному розділі, має складність O(N+M*log(M)). З її характеристик продуктивності ви, мабуть, можете зробити висновок, що це одна з найскладніших команд Redis.

Існує ряд інших складнощів, дві найпоширеніші з яких — `O(N^2)` та `O(C^N)`. Чим більше `N`, тим гірше вони працюють порівняно з меншим `N`. Жодна з команд Redis не має такого типу складності.

Варто зазначити, що нотація `Big O` стосується найгіршого випадку. Коли ми говоримо, що щось займає `O(N)`, ми можемо знайти це відразу або це може бути останній можливий елемент.

## Псевдо-запити за декількома ключами (Pseudo Multi Key Queries)

Часто трапляється ситуація, коли потрібно запитати одне й те саме значення за різними ключами. Наприклад, ви можете захотіти отримати користувача за електронною адресою (коли він вперше входить у систему) і за ідентифікатором (після входу в систему). Одним із жахливих рішень є дублювання об'єкта користувача у двох рядкових значеннях:

```
set users:leto@dune.gov '{"id": 9001, "email": "leto@dune.gov", ...}'
set users:9001 '{"id": 9001, "email": "leto@dune.gov", ...}'
```

Це погано, тому що це кошмар для керування і займає вдвічі більше пам'яті.

Було б добре, якби Redis дозволяв пов'язувати один ключ з іншим, але це неможливо (і, ймовірно, ніколи не буде). Основною метою розробників Redis є збереження чистоти та простоти коду та API. Внутрішня реалізація пов'язування ключів (з ключами можна робити багато речей, про які ми ще не говорили) не варта того, якщо врахувати, що Redis вже надає готове рішення: хеші.

Використовуючи підхід із хешами, ми можемо усунути необхідність дублювання:

```
set users:9001 '{"id": 9001, "email": "leto@dune.gov", ...}'
hset users:lookup:email leto@dune.gov 9001
```

Ми використовуємо поле як псевдо-вторинний індекс і посилаємося на окремий об'єкт користувача. Щоб отримати користувача за ідентифікатором, ми видаємо звичайний запит `get`:

```
get users:9001
```

Щоб отримати електронну пошту користувача, ми виконуємо `hget`, а потім `get` (у Ruby):

```
id = redis.hget('users:lookup:email', 'leto@dune.gov')
user = redis.get("users:#{id}")
```

Це те, що ви, ймовірно, будете робити часто. Як на мене, саме тут хеші справді сяють, але це не очевидний варіант використання, поки ви самі цього не побачите.

## Посилання та індекси (References and Indexes)

Ми розглядали декілька прикладів, коли одне значення посилається на інше. Ми використовували це, коли мали приклад зі списком, а також у розділі вище, коли використовували хеші для спрощення запитів. Суть полягає в тому, що вам доведеться вручну керувати індексами та посиланнями між значеннями. Чесно кажучи, я вважаю, що це трохи прикро, особливо якщо врахувати, що ці посилання доведеться керувати/оновлювати/видаляти вручну. У Redis немає чарівного рішення цієї проблеми.

Ми вже бачили, як набори часто використовуються для реалізації цього типу ручного індексу:

```
sadd friends:leto ghanima paul chani jessica
```

Кожен елемент цього набору є посиланням на рядок Redis, що містить детальну інформацію про фактичного користувача. Що станеться, якщо `chani` змінить своє ім'я або видалить свій обліковий запис? Можливо, доцільно буде відстежувати також зворотні відносини:

```
sadd friends_of:chani leto paul
```

Не враховуючи витрати на обслуговування, якщо ви розділяєте погляди схожі на мої, вас можуть збентежити витрати на обробку та пам'ять, пов'язані з цими додатковими індексованими значеннями. У наступному розділі ми поговоримо про способи зменшення витрат на продуктивність, пов'язаних з необхідністю додаткових циклів (ми коротко згадали про це в першому розділі).

Якщо ж задуматися, то реляційні бази даних мають такі самі накладні витрати. Індекси займають пам'ять, їх потрібно сканувати або, в ідеалі, шукати, а потім знаходити відповідні записи. Накладні витрати акуратно абстрагуються (а також проводиться багато оптимізацій в плані обробки, щоб зробити її дуже ефективною).

Знову ж таки, необхідність вручну обробляти посилання в Redis є недоліком. Але будь-які початкові побоювання щодо продуктивності або впливу на пам'ять слід перевірити. Я думаю, ви переконаєтеся, що це не є проблемою.

## Додаткові запити та конвейерний підхід (Round Trips and Pipelining)

Ми вже згадували, що часті звернення до сервера є типовою практикою в використанні Redis. Оскільки це те, що ви будете робити часто, варто детальніше розглянути, які функції можна використовувати, щоб отримати максимальну продуктивність.

По-перше, багато команд приймають один або кілька наборів параметрів або мають сестринську команду, яка приймає кілька параметрів. Раніше ми бачили команду `mget`, яка приймає кілька ключів і повертає значення:

```
ids = redis.lrange('newusers', 0, 9)
redis.mget(*ids.map {|u| "users:#{u}"})
```

Або команда `sadd`, яка додає 1 або більше елементів до набору:

```
sadd friends:vladimir piter
sadd friends:paul jessica leto "leto II" chani
```

Redis також підтримує конвеєрну обробку. Зазвичай, коли клієнт надсилає запит до Redis, він чекає на відповідь, перш ніж надсилати наступний запит. За допомогою конвеєрної обробки (pipelining) ви можете надсилати кілька запитів, не чекаючи на відповіді. Це зменшує навантаження на мережу та може призвести до значного підвищення продуктивності.

Варто зазначити, що Redis використовуватиме пам'ять для черги команд, тому рекомендується об'єднувати їх у пакети. Розмір пакету залежатиме від використовуваних команд, а точніше, від розміру параметрів. Але якщо ви видаєте команди для ключів довжиною близько 50 символів, їх можна об'єднати в пакети по тисячі або десятки тисяч.

Точний спосіб виконання команд у конвеєрі залежить від драйвера. У Ruby ви передаєте блок до методу `pipelined`:

```
redis.pipelined do
	9001.times do
	redis.incr('powerlevel')
	end
end
```

Як ви, мабуть, здогадуєтеся, конвеєрна обробка (pipelining) може значно пришвидшити імпортування за допомогою пакетів (batch import)!

## Транзакції (Transactions)

Кожна команда Redis є атомарною, включаючи ті, що виконують кілька операцій. Крім того, Redis підтримує транзакції при використанні декількох команд.

Можливо, ви цього не знаєте, але Redis насправді є однопотоковим, що гарантує атомарність кожної команди. Під час виконання однієї команди жодна інша команда не виконується. (Про масштабування ми коротко поговоримо в наступному розділі.) Це особливо корисно, якщо врахувати, що деякі команди виконують кілька операцій. Наприклад:


- `incr` is essentially a `get` followed by a `set`

- `getset` sets a new value and returns the original

- `setnx` first checks if the key exists, and only sets the value if it does not


Хоча ці команди є корисними, вам неминуче доведеться виконувати кілька команд як єдину групу. Для цього спочатку потрібно виконати команду `multi`, а потім усі команди, які ви хочете виконати в рамках транзакції, і нарешті виконати `exec`, щоб фактично виконати команди, або `discard`, щоб відкинути і не виконувати команди. Які гарантії надає Redis щодо транзакцій?

* Команди будуть виконані у відповідності до певного порядку

* Команди будуть виконані як одна атомарна операція (без виконання команд іншого клієнта в процесі виконання).

* Що всі або жодна з команд у транзакції не буде виконана

Ви можете і повинні перевірити це в інтерфейсі командного рядка. Також зверніть увагу, що немає жодних причин, чому ви не можете поєднувати конвеєрну обробку (pipelining) та транзакції (transactions).

```
multi
hincrby groups:1percent balance -9000000000
hincrby groups:99percent balance 9000000000
exec
```

Врешті-решт, Redis дозволяє вказати ключ (або ключі) для спостереження та умовно застосувати транзакцію, якщо ключі зазнали змін. Це використовується, коли потрібно отримати значення та виконати код на основі цих значень, все в одній транзакції. За допомогою наведеного вище коду ми не змогли б реалізувати власну команду `incr`, оскільки всі вони виконуються разом після виклику `exec`. З коду ми не можемо зробити:

```
redis.multi()
current = redis.get('powerlevel')
redis.set('powerlevel', current + 1)
redis.exec()
```

Це не так працює в транзакціях Redis. Але якщо додати `watch` до `powerlevel`, можна зробити так:

```
redis.watch('powerlevel')
current = redis.get('powerlevel')
redis.multi()
redis.set('powerlevel', current + 1)
redis.exec()
```

Якщо інший клієнт змінить значення `powerlevel` після того, як ми викликали `watch` для нього, наша транзакція завершиться з помилкою. Якщо жоден клієнт не змінить значення, набір буде працювати. Ми можемо виконувати цей код у циклі, доки він не запрацює.

## Keys Anti-Pattern

У наступному розділі ми поговоримо про команди, які не пов'язані безпосередньо з структурами даних. Деякі з них є адміністративними або інструментами для налагодження. Але є одна, про яку я хотів би розповісти окремо: команда `keys`. Ця команда бере шаблон і знаходить усі ключі, що відповідають йому. Ця команда здається дуже підходящою для багатьох завдань, але її ніколи не слід використовувати в робочому коді. Чому? Тому що вона виконує лінійне сканування всіх ключів у пошуках збігів. Якщо простіше, то вона повільна.

Як люди намагаються це використовувати? Припустимо, ви створюєте сервіс для відстеження помилок. Кожен обліковий запис матиме ідентифікатор `id`, і ви можете вирішити зберігати кожну помилку у вигляді рядка з ключем, який виглядає так: `bug:account_id:bug_id`. Якщо вам коли-небудь знадобиться знайти всі помилки облікового запису (щоб відобразити їх або, можливо, видалити, якщо користувач видалить свій обліковий запис), ви можете спокуситися (аналогічно як і я!) використати команду `keys`:

```
keys bug:1233:*
```

Кращим рішенням є використання хешу. Так само, як ми можемо використовувати хеші для надання доступу до вторинних індексів, ми можемо використовувати їх для організації наших даних:

```
hset bugs:1233 1 '{"id":1, "account": 1233, "subject": "..."}'
hset bugs:1233 2 '{"id":2, "account": 1233, "subject": "..."}'
```

Щоб отримати всі ідентифікатори помилок для облікового запису, просто викличте `hkeys bugs:1233`. Щоб видалити конкретну помилку, виконайте `hdel bugs:1233 2`, а щоб видалити обліковий запис, видаліть ключ за допомогою `del bugs:1233`.

## У цьому розділі

Цей розділ, разом із попереднім, як я сподіваюсь, дав вам уявлення про те, як використовувати Redis для реалізації реальних функцій. Існує ряд інших шаблонів, які ви можете використовувати для створення будь-яких типів об'єктів, але головне — це зрозуміти основні структури даних і відчути, як їх можна використовувати для реалізації задач, що виходять за межі вашого початкового бачення.

# Розділ 4 - За межами структур даних

Хоча п'ять структур даних складають основу Redis, існують інші команди, які не є специфічними для структур даних. Ми вже бачили декілька з них: `info`, `select`, `flushdb`, `multi`, `exec`, `discard`, `watch` та `keys`. У цьому розділі ми розглянемо деякі інші важливі команди.
## Термін дії (Expiration)

Redis дозволяє позначити ключ для видалення. Ви можете вказати абсолютний час у вигляді Unix-таймстапу (секунди з 1 січня 1970 року) або час існування в секундах. Це команда на основі ключа, тому тип структури даних, яку представляє ключ, не має значення.

```
expire pages:about 30
expireat pages:about 1356933600
```

Перша команда видалить ключ (і пов'язане з ним значення) через 30 секунд. Друга зробить те саме о 12:00 31 грудня 2012 року.

Це робить Redis ідеальним механізмом кешування. Ви можете дізнатися, скільки часу залишилося до закінчення терміну дії елемента, за допомогою команди `ttl`, а також видалити термін дії ключа за допомогою команди `persist`:

```
ttl pages:about
persist pages:about
```

Нарешті, існує спеціальна команда для строкових даних(рядків), `setex`, яка дозволяє встановити рядок і вказати час його існування в одній атомарній команді (це зроблено більше для зручності, ніж для чогось іншого):

```
setex pages:about 30 '<h1>about us</h1>....'
```

## Публікація повідомлень та підписка (Publication and Subscriptions)

Списки Redis мають команди `blpop` та `brpop`, які повертають та видаляють перший (або останній) елемент зі списку або блоків, доки такий елемент не буде доступний. Їх можна використовувати для створення простої черги.

Крім того, Redis має першокласну підтримку публікації повідомлень та підписки на канали. Ви можете спробувати це самостійно, відкривши друге вікно `redis-cli`. У першому вікні підпишіться на канал (назвемо його `warnings`):

```
subscribe warnings
```

Відповідь містить інформацію про вашу підписку. Тепер в іншому вікні опублікуйте повідомлення в каналі `warnings`:

```
publish warnings "it's over 9000!"
```

Якщо ви повернетеся до першого вікна, ви повинні отримати повідомлення в каналі `warnings`.

Ви можете підписатися на кілька каналів (`subscribe channel1 channel2 ...`), або здійснити підписку на канали за певним шаблоном (`psubscribe warnings:*`) та використовувати команди `unsubscribe` і `punsubscribe`, щоб припинити прослуховування одного або декількох каналів або шаблону каналів.

Нарешті, зверніть увагу, що команда `publish` повернула значення 1. Це вказує на кількість клієнтів, які отримали повідомлення.


## Моніторинг та журнал повільних запитів (Monitroing and Slow Log)

Команда `monitor` дозволяє побачити, що робить Redis. Це чудовий інструмент для налагодження, який дає уявлення про те, як ваша програма взаємодіє з Redis. В одному з двох вікон redis-cli (якщо одне з них все ще підключене, ви можете скористатися командою `unsubscribe` або закрити вікно і відкрити нове) введіть команду `monitor`. В іншому вікні виконайте будь-яку іншу команду (наприклад, `get` або `set`). Ви повинні побачити ці команди разом з їх параметрами в першому вікні.

Слід бути обережним при використанні монітора в `production` середовищі , оскільки це інструмент для налагодження та розробки. Крім цього, про нього немає чого додати. Це просто дуже корисний інструмент.

Поряд з `monitor`, Redis має `slowlog`, який є чудовим інструментом для профілювання. Він реєструє всі команди, виконання яких триває довше, ніж задана кількість **мікро**секунд. У наступному розділі ми коротко розглянемо, як налаштувати Redis. А поки що ви можете налаштувати Redis на реєстрацію всіх команд, ввівши:

```
config set slowlog-log-slower-than 0
```

Далі виконайте кілька команд. Нарешті, ви можете отримати всі журнали або найновіші журнали за допомогою:

```
slowlog get
slowlog get 10
```

Ви також можете отримати кількість елементів у повільному журналі, ввівши `slowlog len`.

Для кожної введеної команди ви повинні побачити чотири параметри:

*  Авто-інкремент ідентифікатора

* Unix timestamp, що позначає момент виконання команди

* Час у мікросекундах, який знадобився для виконання команди.

* Команда та її параметри

Журнал повільних запитів зберігається в пам'яті, тому його запуск на `production`, навіть із низьким порогом, не повинен викликати проблем. За замовчуванням він відстежує останні 1024 записи.
## Сортування (Sort)

Однією з найпотужніших команд Redis є `sort`. Вона дозволяє сортувати значення в списку, наборі або впорядкованому наборі (впорядковані набори сортуються за балами, а не за елементами набору). У найпростішому вигляді вона дозволяє нам робити наступне:

```
rpush users:leto:guesses 5 9 10 2 4 10 19 2
sort users:leto:guesses
```

Це поверне значення, відсортовані від найменшого до найбільшого. Ось більш складний приклад:

```
sadd friends:ghanima leto paul chani jessica alia duncan
sort friends:ghanima limit 0 3 desc alpha
```

Вищезазначена команда показує, як розбити на сторінки відсортовані записи (за допомогою `limit`), як повернути результати в порядку спадання (за допомогою `desc`) і як сортувати лексикографічно, а не числово (за допомогою `alpha`).

Справжня сила команди `sort` полягає в її здатності сортувати на основі об'єкта, на який є посилання. Раніше ми показали, як списки, множини та впорядковані множини часто використовуються для посилання на інші об'єкти Redis. Команда `sort` може отримувати значення за цими посиланнями і сортувати їх. Наприклад, припустимо, що ми маємо систему відстеження помилок (баґ-трекер), яка дозволяє користувачам стежити за проблемами. Ми можемо використовувати набір для відстеження проблем, які переглядаються:

```
sadd watch:leto 12339 1382 338 9338
```

Цілком логічно сортувати їх за ідентифікатором (що і робить сортування за замовчуванням), але ми також хотіли б сортувати їх за ступенем важливості. Для цього ми вказуємо Redis, за яким шаблоном сортувати. Спочатку додамо ще трохи даних, щоб побачити значущий результат:

```
set severity:12339 3
set severity:1382 2
set severity:338 5
set severity:9338 4
```

Щоб відсортувати помилки за ступенем серйозності, від найвищого до найнижчого, потрібно зробити наступне:

```
sort watch:leto by severity:* desc
```

Redis замінить символ `*` у нашому шаблоні (ідентифікований за допомогою `by`) значеннями з нашого списку/набору/відсортованого набору. Це створить ім'я ключа, яке Redis буде запитувати для сортування за фактичними значеннями.

Хоча в Redis можна мати мільйони ключів, я вважаю, що вищезазначений підхід може бути дещо заплутаним. На щастя, `sort` також може працювати з хешами та їхніми полями. Замість того, щоб мати безліч ключів верхнього рівня, ви можете використовувати хеші:

```
hset bug:12339 severity 3
hset bug:12339 priority 1
hset bug:12339 details '{"id": 12339, ....}'

hset bug:1382 severity 2
hset bug:1382 priority 2
hset bug:1382 details '{"id": 1382, ....}'

hset bug:338 severity 5
hset bug:338 priority 3
hset bug:338 details '{"id": 338, ....}'

hset bug:9338 severity 4
hset bug:9338 priority 2
hset bug:9338 details '{"id": 9338, ....}'
```

Відтак, все не тільки все краще організовано, і ми можемо сортувати за «серйозністю» або «пріоритетом», але ми також можемо вказати «sort», яке поле потрібно витягти:

```
sort watch:leto by bug:*->priority get bug:*->details
```

Відбувається заміщення значення, але Redis також розпізнає послідовність `->` і використовує її для пошуку вказаного поля нашого хешу. Ми також додали параметр `get`, який також виконує заміщення та пошук поля, щоб отримати детальну інформацію про помилку.

При роботі з великими наборами даних команда `sort` може працювати повільно. Хороша новина полягає в тому, що результат роботи команди `sort` можна зберегти:

```
sort watch:leto by bug:*->priority get bug:*->details store watch_by_priority:leto
```

Поєднання можливостей `store` команди `sort` з командами терміну дії, які ми вже бачили може допомогти створити чудову комбінацію.

## Сканування (Scan)

У попередньому розділі ми побачили, що команда `keys`, хоч і корисна, але не повинна використовуватися в `production`. Redis 2.8 вводить команду `scan`, яка є безпечною в `production`. Хоча `scan` виконує подібну функцію до `keys`, між ними є ряд важливих відмінностей. Відверто кажучи, більшість *відмінностей* здаватимуться *особливостями*, але це ціна за наявність корисної команди.

Перша з цих відмінностей полягає в тому, що один виклик `scan` не обов'язково повертає всі відповідні результати. У результатах, що відображаються на сторінках, немає нічого дивного, однак `scan` повертає змінну кількість результатів, яку неможливо точно контролювати. Ви можете вказати підказку `count`, яка за замовчуванням дорівнює 10, але цілком можливо отримати більше або менше, ніж вказано в `count`.

Замість того, щоб реалізовувати перегортання сторінок за допомогою `limit` та `offset`, `scan` використовує `cursor`. При першому виклику `scan` ви вказуєте `0` як курсор. Нижче ми бачимо початковий виклик `scan` з відповідністю шаблону (опціонально) та підказкою щодо кількості (опціонально):

```
scan 0 match bugs:* count 20
```

У рамках своєї відповіді `scan` повертає наступний курсор, який слід використовувати. Або scan повертає `0`, щоб позначити кінець результатів. Зверніть увагу, що наступне значення курсора не відповідає номеру результату або будь-чому іншому, що клієнти можуть вважати корисним.

Типова послідованість виконання може виглядати так:

```
scan 0 match bugs:* count 2
> 1) "3"
> 2) 1) "bugs:125"
scan 3 match bugs:* count 2
> 1) "0"
> 2) 1) "bugs:124"
>    2) "bugs:123"
```

Наш перший виклик повернув наступний курсор (3) і один результат. Наш наступний виклик, використовуючи наступний курсор, повернув кінцевий курсор (0) і два останніх результати. Вище описано *типову* послідовність (flow). Оскільки `count` є лише підказкою, `scan` може повернути наступний `cursor` (не 0) без фактичних результатів. Іншими словами, порожній набір результатів не означає, що додаткових результатів не існує. Тільки курсор 0 означає, що додаткових результатів немає.

З позитивного боку, `scan` є повністю безстановою з точки зору Redis. Тому немає необхідності закривати курсор і немає нічого поганого в тому, що результат не прочитано повністю. Якщо ви хочете, ви можете зупинити ітерацію результатів, навіть якщо Redis повернув дійсний наступний курсор.

Є ще дві речі, про які слід пам'ятати. По-перше, `scan` може повернути один і той самий ключ кілька разів. Вирішувати, як впоратися з цим, вам доведеться самостійно (найімовірніше, зберігаючи набір вже побачених значень). По-друге, `scan` гарантує повернення лише тих значень, які були присутні протягом усього періоду ітерації. Якщо під час ітерації значення додаються або видаляються, вони можуть бути повернуті або ні. Це знову ж таки пов'язано з характером відсутності стану (statelessness) `scan`; він не робить знімок існуючих значень (як це роблять багато баз даних, що забезпечують високу узгодженість), а ітерує той самий простір пам'яті, який може бути змінений або не змінений.

Крім команд `scan`, `hscan`, `sscan` та `zscan` також були додані команди `hscan`, `sscan` та `zscan`. Вони дозволяють перебирати хеші, набори та впорядковані набори. Навіщо вони потрібні? Так само, як `keys` блокує всі інші виклики, так само і команда хешу `hgetall` та команда набору `smembers`. Якщо ви хочете пройти по дуже великому хешу або набору, ви можете скористатися цими командами. `zscan` може здатися менш корисним, оскільки перегляд сортованого набору за допомогою `zrangebyscore` або `zrangebyrank` вже можливий. Однак, якщо ви хочете повністю пройти по великому сортованому набору, `zscan` має певну цінність.

## У цьому розділі

Цей розділ присвячений командам, що не стосуються конкретних структур даних. Як і все інше, їх використання залежить від ситуації. Нерідко створюються програми або функції, які не використовують терміни дії, публікацію/підписку та/або сортування. Але добре знати, що вони існують. Крім того, ми розглянули лише деякі команди. Існує ще більше, і після того, як ви засвоїте матеріал цієї книги, варто ознайомитися з [повним списком](http://redis.io/commands).

# Розділ 5 - Lua скриптинг

Redis 2.6 включає вбудований інтерпретатор `Lua`, який розробники можуть використовувати для написання більш складних запитів, що виконуються в Redis. Не буде помилкою порівняти цю функцію із збереженими процедурами, доступними в більшості реляційних баз даних.

Найскладнішим аспектом освоєння цієї функції є вивчення мови `Lua`. На щастя, `Lua` схожа на більшість мов загального призначення, добре документована, має активну спільноту і корисна не тільки для написання скриптів Redis. У цьому розділі ми не будемо детально розглядати Lua, але кілька прикладів, які ми розглянемо, сподіваємося, стануть простим вступом до цієї мови.

## Why?

Перш ніж розглянути, як використовувати скрипти Lua, ви, можливо, запитаєте себе, навіщо це потрібно. Багато розробників не люблять традиційні збережені процедури, чи є це чимось іншим? Коротка відповідь — ні. Неправильне використання скриптів Lua в Redis може призвести до ускладнення тестування коду, тісного зв'язку бізнес-логіки з доступом до даних або навіть дублювання логіки.

Однак при правильному використанні ця функція може спростити код і покращити продуктивність. Обидві ці переваги в основному досягаються шляхом об'єднання декількох команд разом із простою логікою в спеціальну функцію. Код стає простішим, оскільки кожне виклик скрипта Lua виконується без перерв, що забезпечує чіткий спосіб створення власних атомних команд (що, по суті, усуває необхідність використання громіздкої команди `watch`). Це може покращити продуктивність, усунувши необхідність повернення проміжних результатів — кінцевий результат можна обчислити в рамках скрипта.

Приклади в наступних розділах краще проілюструють ці моменти.

## Eval

Команда `eval` приймає скрипт `Lua` (у вигляді рядка), ключі, з якими ми будемо працювати, та опціональний набір довільних аргументів. Давайте розглянемо простий приклад (виконаний з Ruby, оскільки виконувати багаторядкові команди Redis з командного рядка не дуже приємно):

```
script = <<-eos
	local friend_names = redis.call('smembers', KEYS[1])
	local friends = {}
	for i = 1, #friend_names do
	local friend_key = 'user:' .. friend_names[i]
	local gender = redis.call('hget', friend_key, 'gender')
	if gender == ARGV[1] then
		table.insert(friends, redis.call('hget', friend_key, 'details'))
	end
	end
	return friends
eos
Redis.new.eval(script, ['friends:leto'], ['m'])
```

Вищезазначений код отримує детальну інформацію про всіх чоловіків-друзів Лето. Зверніть увагу, що для виклику команд Redis у нашому скрипті ми використовуємо метод `redis.call(«command», ARG1, ARG2, ...)`.

Якщо ви новачок у `Lua`, вам слід уважно прочитати кожен рядок. Може бути корисно знати, що `{}` створює порожній `table` (який може діяти як масив або словник), `#TABLE` отримує кількість елементів у TABLE, а `..` використовується для об'єднання рядків.

`eval` насправді приймає 4 параметри. Другий параметр повинен бути кількістю ключів, однак драйвер Ruby автоматично створює його для нас. Навіщо це потрібно? Подивіться, як виглядає вищезазначений код при виконанні з командного рядка:

```
eval "....." "friends:leto" "m"
vs
eval "....." 1 "friends:leto" "m"
```

У першому (неправильному) випадку, як Redis визначає, які параметри є ключами, а які просто довільними аргументами? У другому випадку двозначності немає.

Це викликає друге питання: чому ключі повинні бути явно вказані? Кожна команда в Redis знає під час виконання, які ключі будуть потрібні. Це дозволить майбутнім інструментам, таким як Redis Cluster, розподіляти запити між декількома серверами Redis. Ви, мабуть, помітили, що в нашому прикладі вище фактично відбувається динамічне читання з ключів (без передачі їх до `eval`). Команда `hget` виконується для всіх чоловіків-друзів Лето. Це тому, що необхідність заздалегідь перелічити ключі є скоріше рекомендацією, ніж жорстким правилом. Наведений вище код буде працювати нормально в конфігурації з одним екземпляром або навіть з реплікацією, але не буде працювати в ще не випущеному Redis Cluster.

## Керування скриптами (Script Management)

Хоча скрипти, що виконуються за допомогою `eval`, кешуються Redis, надсилання тіла кожного разу, коли ви хочете щось виконати, не є ідеальним рішенням. Натомість ви можете зареєструвати скрипт у Redis і виконати його ключ. Для цього використовуйте команду `script load`, яка повертає SHA1-дайджест скрипта:

```
redis = Redis.new
script_key = redis.script(:load, "THE_SCRIPT")
```

Після завантаження скрипта ми можемо виконати його за допомогою команди `evalsha`:

```
redis.evalsha(script_key, ['friends:leto'], ['m'])
```

`script kill`, `script flush` та `script exists` — це інші команди, які можна використовувати для керування скриптами `Lua`. Вони використовуються для завершення роботи скрипта, видалення всіх скриптів із внутрішнього кешу та перевірки наявності скрипта в кеші.

## Бібліотеки (Libraries)

Реалізація Redis `Lua` постачається з декількома корисними бібліотеками. Хоча `table.lib`, `string.lib` та `math.lib` є досить корисними, на мій погляд, варто виділити `cjson.lib`. По-перше, якщо вам доводиться передавати кілька аргументів до скрипта, може бути зручніше передавати їх у форматі JSON:

```
redis.evalsha ".....", [KEY1], [JSON.fast_generate({gender: 'm', ghola: true})]
```

Який потім можна десеріалізувати в скрипті Lua наступним чином:

```
local arguments = cjson.decode(ARGV[1])
```

Звичайно, бібліотека JSON також може бути використана для аналізу значень, що зберігаються в самій Redis. Наш приклад вище можна переписати таким чином:

```
      local friend_names = redis.call('smembers', KEYS[1])
      local friends = {}
      for i = 1, #friend_names do
        local friend_raw = redis.call('get', 'user:' .. friend_names[i])
        local friend_parsed = cjson.decode(friend_raw)
        if friend_parsed.gender == ARGV[1] then
          table.insert(friends, friend_raw)
        end
      end
      return friends
```

Замість того, щоб отримувати стать з конкретного поля хешу, ми могли б отримувати її з самих збережених даних про друзів. (Це набагато повільніше рішення, і я особисто віддаю перевагу оригінальному, але воно показує, що таке можливо).

## Атомарність (Atomic)

Оскільки Redis є однопотоковим, вам не потрібно турбуватися про те, що ваш скрипт `Lua` буде перерваний іншою командою Redis. Однією з найочевидніших переваг цього є те, що ключі з TTL не будуть закінчуватися в середині виконання. Якщо ключ присутній на початку скрипта, він буде присутній у будь-який момент після цього, якщо ви його не видалите.

## Адміністрування (Administration)

У наступному розділі ми більш детально розглянемо адміністрування та налаштування Redis. Наразі достатньо знати, що параметр `lua-time-limit` визначає, скільки часу скрипт Lua може виконуватися перед тим, як буде завершено. За замовчуванням встановлено досить велике значення — 5 секунд. Розгляньте можливість його зменшення.

## У цьому розділі

У цьому розділі було представлено можливості скриптів `Lua` в Redis. Як і будь чим іншим, цією функцією можна зловживати. Однак, якщо використовувати її розсудливо для реалізації власних налаштованих і цілеспрямованих команд, вона не тільки спростить ваш код, але й, ймовірно, покращить продуктивність. Скрипти Lua подібні до майже всіх інших функцій/команд Redis: спочатку ви використовуєте їх обмежено, якщо взагалі використовуєте, а потім з кожним днем все більше і більше.

# Розділ 6 - Адміністрування

Останній розділ присвячений деяким адміністративним аспектам роботи Redis. Це аж ніяк не вичерпний посібник з адміністрування Redis. У кращому разі ми відповімо на деякі найпоширеніші запитання, які можуть виникнути у нових користувачів Redis.

## Конфігурація (Configuration)

Коли ви вперше запустили сервер Redis, з'явилося попередження про те, що файл `redis.conf` не знайдено. Цей файл можна використовувати для налаштування різних аспектів Redis. Для кожної версії Redis доступний добре задокументований файл `redis.conf`. Файл-зразок містить параметри конфігурації за замовчуванням, тому він корисний як для розуміння призначення налаштувань, так і для ознайомлення з їхніми значеннями за замовчуванням. Його можна знайти за адресою <http://download.redis.io/redis-stable/redis.conf>.

Оскільки файл добре задокументований, ми не будемо розглядати налаштування.

Окрім налаштування Redis за допомогою файлу `redis.conf`, для встановлення окремих значень можна використовувати команду `config set`. Фактично, ми вже використовували її під час встановлення параметра `slowlog-log-slower-than` на 0.

Також є команда `config get`, яка відображає значення налаштування. Ця команда підтримує зіставлення з шаблоном. Отже, якщо ми хочемо відобразити все, що стосується журналу, ми можемо зробити так:

```
config get *log*
```

## Аутентифікація (Authentication)

Redis можна налаштувати так, щоб вимагати введення пароля. Це робиться за допомогою параметра `requirepass` (встановлюється через файл `redis.conf` або команду `config set`). Коли `requirepass` встановлено на значення (яке є паролем для використання), клієнти повинні видати команду `auth password`.

Після автентифікації клієнт може видавати будь-які команди для будь-якої бази даних. Це включає команду `flushall`, яка видаляє всі ключі з усіх баз даних. За допомогою конфігурації ви можете перейменувати команди, щоб досягти певного рівня безпеки за допомогою обфускації:

```
rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
rename-command FLUSHALL 1041285018a942a4922cbf76623b741e
```

Або ви можете вимкнути команду, встановивши нове ім'я як порожній рядок.

## Обмеження розміру (Size Limitations)

Починаючи користуватися Redis, ви можете задатися питанням: «Скільки ключів я можу мати?» Ви також можете задатися питанням, скільки полів може мати хеш (особливо коли ви використовуєте його для організації даних) або скільки елементів можуть мати списки та набори? Наприклад, практичні обмеження для всіх цих елементів становлять сотні мільйонів.

## Реплікація (Replication)

Redis підтримує реплікацію, що означає, що під час запису в один екземпляр Redis (lader) один або кілька інших екземплярів (replica) оновлюються лідером. Для налаштування реплік використовуйте параметр конфігурації `slaveof` або команду `slaveof` (екземпляри, що працюють без цієї конфігурації, є або можуть бути майстрами).

Реплікація допомагає захистити ваші дані шляхом копіювання на різні сервери. Реплікація також може використовуватися для підвищення продуктивності, оскільки запити на читання можуть надсилатися на підлеглі сервери. Вони можуть відповідати з дещо застарілими даними, але для більшості додатків це прийнятний компроміс.

На жаль, реплікація Redis ще не забезпечує автоматичне переключення на резервний сервер. Якщо головний сервер (leader) виходить з ладу, для підлеглого серверу (replica) потрібно вручну поміняти статус. Традиційні інструменти високої доступності, які використовують моніторинг серцебиття (heartbeath) та скрипти для автоматизації перемикання, наразі є необхідним головним болем, якщо ви хочете досягти певного рівня високої доступності за допомогою Redis.

## Резервне копіювання даних (Backups)

Створення резервної копії Redis — це просто копіювання знімка Redis у будь-яке місце (S3, FTP тощо). За замовчуванням Redis зберігає знімок у файлі з назвою `dump.rdb`. У будь-який момент ви можете просто скопіювати цей файл за допомогою `scp`, `ftp` або `cp` (або будь-яким іншим способом).

Нерідко трапляється, що на майстер-сервері вимикають як створення знімків, так і файл тільки для додавання (aof), а це завдання доручають веб-серверу. Це допомагає зменшити навантаження на майстер-сервер і дозволяє встановити більш агресивні параметри збереження на веб-сервері без шкоди для загальної швидкості роботи системи.

## Масштабування та кластерізація Redis (Scaling and Redis Cluster)

Реплікація — це перший інструмент, який може використовувати сайт, що розвивається. Деякі команди є дорожчими за інші (наприклад, `sort`) і перенесення їх виконання на підлеглий сервер може забезпечити загальну швидкість реагування системи на вхідні запити.

Крім цього, справжнє масштабування Redis зводиться до розподілу ключів між декількома екземплярами Redis (які можуть працювати на одному комп'ютері, пам'ятайте, що Redis є однопотоковим). Наразі це те, про що вам потрібно подбати (хоча деякі драйвери Redis надають алгоритми послідовного хешування). Розгляд даних з точки зору горизонтального розподілу не входить до обсягу цієї книги. Це також питання, про яке вам, ймовірно, не доведеться турбуватися найближчим часом, але про яке потрібно пам'ятати незалежно від того, яке рішення ви використовуєте.

Хороша новина полягає в тому, що робота над Redis Cluster вже ведеться. Це не тільки забезпечить горизонтальне масштабування, включаючи перерозподіл навантаження, але й автоматичне переключення на резервний ресурс для високої доступності.

Висока доступність (High Availability) і масштабованість (scaling) — це те, чого можна досягти сьогодні, якщо ви готові витратити на це час і зусилля. У майбутньому Redis Cluster повинен значно спростити цю задачу.

## У цьому розділі

З огляду на кількість проектів і сайтів, які вже використовують Redis, можна без сумніву стверджувати, що Redis вже давно готовий до використання у `production`. Однак деякі інструменти, особливо ті, що стосуються безпеки та доступності, ще перебувають на стадії розробки. Redis Cluster, який, сподіваємося, з'явиться незабаром, повинен допомогти вирішити деякі з поточних проблем управління.

# Висновки

Багато в чому Redis спрощує роботу з даними. Він позбавляє нас від значної частини складності та абстракції, притаманних іншим системам. У багатьох випадках це робить Redis неправильним вибором. В інших випадках може здатися, що Redis був створений спеціально для ваших даних.

Зрештою, все повертається до того, про що я сказав на самому початку: Redis легко вивчити. Існує багато нових технологій, і буває важко зрозуміти, на що варто витратити час. Якщо врахувати реальні переваги Redis та його простоту, я щиро вірю, що це одна з найкращих інвестицій у навчання, яку ви та ваша команда можете зробити.
